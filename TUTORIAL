TUTORIAL 
========
This little tutorial shows you how to backup your LINUX file system 
(partially or totally) on ZIP drives.


STEP 1: the FULL backup
------------------------

We need first to make a full backup, let's go:

the size of a zip drive is 100 MB, 
*** here comes the option: -s 100M
this tells dar to not create a single backup file but to split it in several
files with a size of at most 100 Megabytes.

But on your first ZIP drive you want to copy the dar binary outside the
backup to be able to restore it in case of hard disk failure for example.
IMPORTANT : dar binary relies on several libraries which must also be available
in the rescue system or copied with the dar binary. But, if you don't want to
worry about needed libraries, there is a static version of dar which only 
difference is that it has all required library included in the binary (thus it
is a bit larger binary). Its name is "dar_static", and its main reason of 
existance is to be placed beside backups in case something goes wrong in your
system. Note that dar_static is useless for windows, you will always need 
the cygwin dll.

(you could also add man pages, if you are scared not to be able to remember
all the many feature of dar ;-) and find the -h option too sparse). Note
that man pages are available on the web. OK you need an Internet access to
read them.

This make the free space on the first ZIP floppy a bit smaller: 95 MB. 
*** Here comes the option: -S 95M  
(note that '-s' is lowercase for all the slices, and '-S' is UPPERCASE meaning 
the initial slice only).

we need to pause between slices to change the ZIP floppy when it is full
*** here comes the option: -p -b
telling dar to pause before writing a new slice (-p) and to ring the terminal
bell (-b) when user action is needed. 

we will compress data inside the backup
*** here comes the option: -z

now, we want to backup the whole file system.
*** here comes the option: -R /
this tells dar that no files out of this directory tree will be saved (here, it
means that no files will be excluded from the backup, if no filter is 
specified, see below)

there are some files you don't want to backup like backup files generated by
emacs "*~" and .*~".
*** here comes the options: -X "*~" -X ".*~" 
note that you have to quote the mask for it not to be interpreted by the shell
 
over theses files, there is several sub-trees you must not save: the proc 
file system for example, as well as the /dev/pts . Theses are virtual 
file systems, saving them would only make your backup bigger filled with 
not useful stuff.
*** here come the options: -P dev/pts -P proc
Note that path must be relative to -R option

moreover we must not save the backup itself:
*** here comes the option: -P mnt/zip
assuming that your ZIP is mounted under /mnt/zip
you should also have excluded all files of extension "dar" which are
backup generated by dar with -X "*.dar", but this would exclude other
dar archive from the backup.

Now, as we don't save the /dev/pts /proc and /mnt/zip directories, 
we would have to create them by hand at recovery time. But we can better use
the -D option, which does not totally ignore excluded directories but rather
stores them as empty.
*** here comes the option -D
thus at recovery time they will be generated automatically

last we have to give a name to this full backup. Let's call it "linux_full"
as it is supposed to take place on the ZIP drive, its path is 
/mnt/zip/linux_full
*** here comes the option: -c /mnt/zip/linux_full
note that linux_full is not a complete filename, it is a "basename", on 
which dar will add a number and an extension ".dar", this way the first
slice will be a file of name linux_full.1.dar located in /mnt/zip

now, as we will have to mount and umount the /mnt/zip file system, we must
not have any process using it, in particular, dar current directory must no
be /mnt/zip so we change to / for example. 
all together it makes:

put an empty ZIP floppy in the device, and mount it according to your 
/etc/fstab file.
	mount /mnt/zip
copy the dar binary to the zip drive (to be able to restore in case of big 
problem, like a crash disk) and eventually man pages
	cp `which dar` /mnt/zip
then, type the following
	cd /
	dar -c /mnt/zip/linux_full -s 100M -S 95M -p -b -z -R / -X "*~" -X ".*~" -P dev/pts -P proc -P mnt/zip -D

note that option order has no importance.
when the first slice will be done, DAR will pause, ring and display a message.
you will have to unmount the floppy
	umount /mnt/zip
eject and replace the floppy by an empty new one and mount it
	mount /mnt/zip
then proceed with dar, pressing the <enter> key.

dar will label slices this way:
slice 1: linux_full.1.dar
slice 2: linux_full.2.dar
and so on.

That's it we finished the first step, it may take a long time depending on the
size of the data to backup, but, for the following step (differential backup)
it can be done often it will stay fast every time (OK, except if a big part of
you system have changed, in that case you can consider making another full 
backup).

Just a little check on the archive you've just made:
suppose you want to read the content of the backup you made, you would have 
to run:

	dar -l /mnt/zip/linux_full

optionally if you don't trust your zip floppies, you can either check the 
archive contents, or compare what's stored in it with the current file
system.

	dar -t /mnt/zip/linux_full
will check the directory contents,
 
it is recommended to first unmount it and remount it, this to flush the cache.
Else you may read data from cache (in memory) and do not detect an error on you
floppy. dar -t cannot check a single slice, it checks all the archive. If you 
need to check use the diff command. For example, you burn slices on CD-R, but
have just enough free space to store one slice on disk. After burning check the
slice is correct using for example

	diff /mnt/cdrom/slice.x.dar /tmp/slice.x.dar

if all is ok, you can delete the slice from the hard disk (/tmp/slice.x.dar),
and continue with dar. Else, you will have to burn again the slice on a new
CD-R.


	dar -d /mnt/zip/linux_full -R /

will compare the archive with filesystem tree located at /
Same remark as previously, it is recommended to first unmount and mount 
the floppy to flush the cache.

STEP 2: DIFFERENTIAL BACKUP
-------------------------------
The only thing to add is the base name of the backup we take as reference
*** here comes the option: -A /mnt/zip/linux_full

of course, we have to choose another name for that backup, let's call it
linux_diff1 
*** here comes the option: -c /mnt/zip/linux_diff1

last point, if you want to put the new backup at the end of the full backup,
you will have to change the -S option according to the remaining space on it.
suppose the last slice of linux_full takes 34MB you have 76MB available for the
first slice (and always 100MB for the following ones),
*** here comes the option: -S 76M
but if you want to put the backup on a new floppy, just forget the -S option.

all together it makes:
	dar -c /mnt/zip/linux_diff1 -A /mnt/zip/linux_full -s 100M -S 76M -p -b -z -R / -X "*~" -X ".*~" -P dev/pts -P proc -P mnt/zip -D

the same way we have done previously, just before effectively starting to 
backup, dar will ask for the first and then the last slice of the archive of
reference, then dar will pause for you to change the floppy and put the one
you want to put the backup on.

STEP 3: ENDLESS DIFFERENTIAL BACKUP
------------------------------------
you can make another differential backup, taking linux_diff1 as reference,
in this case you would change only the following
-c /mnt/zip/linux_diff2 -A /mnt/zip/linux_diff1
you could also decide to change of device, taking a 1'44MB floppy or a CD-R,
this would not cause any problem at all. It arrives a time when you get
many differential backup for a single full backup, it is then time
to make a new full backup, depending on your available time for doing it, or
on your patient if one day you have to recover the whole data after a disk
crash: you would then have to restore the full backup, then all the following
differential backup up to the most recent one. This requires more user 
intervention than restoring a single full backup, all is a matter of balance,
between the time it takes to backup and the time it takes to restore.

Note, that starting release 1.2.0 a new command appeared that helps restoring
a small set of file from a lot a differential backup. Its name is dar_manager.
See man page for more. 

Another solution, is when you have too much differential backup, is to make 
the next differential backup taking the last full_backup as reference, instead
of the last differential backup done. This way, it will take less time than 
doing a full backup, and you will not have to restore all intermediate
differential backup. 
Some people make difference between "incremental" backup and "differential"
backup, here they are the same, all depends on the nature of the reference
backup you take.


Of course, a given backup can be used as reference for several differential
backup, there is no limitation in number nor in nature (the reference can 
be a full of differential backup).


STEP 4: RECOVER AFTER A DISK CRASH
------------------------------------
Sorry, it arrived, your old disk has crashed. OK, you are happy because, you
have now a good argument to buy the very fast and very enormous very last
hard disk available. Usually, you also cry because you have lost data and you
will have to reinstall all you system, that was working for so long !

But if the last backup you made is recent, then keep smiling !
OK, you have installed your new hard disk and configured you BIOS to it (if 
necessary).
You will need a bootable floppy, with a minimum Linux system on it, that
allows you to access your zip drive and your new empty hard disk 
(in the case your backup resided on ZIP disk). For example use the Slackware 
floppy disks, they are nicely done. You don't need to install something on 
your brand-new disk, just make partitions and format as you want:
We suppose your new disk is /dev/hda and /dev/sga is your ZIP drive.

1. create the partition table as you wish, using
	fdisk /dev/hda

2. format the ext2 partition which will receive your data
	mke2fs /dev/hda1

3. additionally format the swap partition (if need)
	mkswap -c /dev/hda2

4. now we must mount the hard disk, somewhere.
	cd /
	mkdir disk
	mount -t ext2 /dev/hda1 /disk
would do the trick

5. we need to copy the dar binary from the ZIP to your disk
insert the floppy ZIP where you have copied the dar binary
	cd /
	mkdir zip
	mount -t ext2 /dev/sga /zip
	cp /zip/dar /disk
where /dev/sga points to your zip drive	

6. now we restore the archive.
the stuff has to go in /disk subdirectory
*** here comes the option: -R /disk

let's go restoring !
	/disk/dar -x /zip/linux_full -R /disk

and when the next zip floppy is needed, 
	umount /zip
change the floppy and mount it:
	mount -t ext2 /dev/sga /zip
then press <enter> to proceed with dar
you can type theses last command either using another virtual console 
(pressing ALT-F1, etc. under Linux), or suspending dar with Control-Z. 
You will have then to reactive it with the "fg" shell command once the floppy 
is changed and mounted.

7. Once finished with the restoration of linux_full, we have to do the same 
with any following backup, but, this way, dar will warn you any time it 
restores a more recent file (file overwriting) or any time a file that has been
removed since the backup of reference, has to be removed from file system 
(suppression). If you don't want to press the <enter> key several thousand 
times,
*** here comes the option: -w
(don't warn)
all file will be overwritten without warning, but you may also use the -r 
option, that will avoid trying to overwrite more recent files than those
on filesystem. It might not be of a great use, if you restore a differential
backup after its reference backup on an initially empty disk (file stored
in the differential archive are more recent than those in the reference). 
But, it might be useful in some other situations. 

all together it makes:
	/disk/dar -x /zip/linux_diff1 -R /disk -w

then any additional archive:
	/disk/dar -x /zip/linux_diff2 -R /disk -w
	...
	/disk/dar -x /zip/linux...    -R /disk -w

8. Finally, remove the dar binary from the disk:
	rm /disk/dar

9. and launch lilo for your Linux box to boot properly:
	lilo -r /disk

10. you can reboot you machine and be happy with you brand-new hard disk with
your old precious data on it:
	shutdown -r now

OK, one day, I will make something like a bootable floppy image with dar 
inside, maybe with a simple script for user interaction... if you have already 
done it, you can forward it to me to be published on the dar web site.


STEP 4(bis): recover only some files
--------------------------------------
Gosh, you have remove a important file by error. Thus, you just need to restore
it, not the rest of the full and differential backups. 

a) first method:
'''''''''''''''''''
We could as previously, try all archive starting from the full backup up to 
the most recent differential backup, and restore just the file if it is 
present in the archive:

	dar -x /zip/linux_full -R / home/denis/my_precious_file

this would restore only the file /home/denis/my_precious_file from the full 
backup. Note that -R has / as argument and not /home/denis/my_precious_file.
Thus there is a space between / and home. Giving 
-R /home/denis/my_precious_file, would try to restore the whole backup under
the directory /home/denis/my_precious_file (if it exists) which is not what we
want here, thus don't forget the space character between / and 
home/denis/my_precious_file

OK, now we would also have to restore from all differential backup the same 
way we did. Of course, this file may have changed since the full backup.
	
	dar -x /zip/linux_diff1 -R / home/denis/my_precious_file

and so on, up to the last differential archive.

	dar -x /zip/linux_diff29 -R / home/denis/my_precious_file 


b) second method (more efficient):
'''''''''''''''''''''''''''''''''''''''
We will restore our lost file, starting from the most recent differential 
backup and *maybe* up to the full backup. Our file may or may not be present 
in the each differential archive as it may have changed or not since the 
previous version, thus we have to check if our file is restored, using the
-v option:

	dar -x /zip/linux_diff29 -R / -v home/denis/my_precious_file

if we can see a line like 

	restore file: /home/denis/my_precious_file

thus we stop here, because we got the most recent backup version of our lost 
file. Else, we have to continue with the previous differential backup, up
to the full backup if it is necessary. 
This method has an advantage over first one, which is not to have *in all case*
the need to use all the backup done since the full backup.

but if you are lazy, have a look at dar_manager man page !
'''''''''''''''''''''''''''''''

OK, now you have two files to restore ? No problem, just do the second method
but add -r option not to override any more recent file already restored in a
previous step:

	dar -x /zip/linux_diff29 -R / -r -v home/denis/my_precious_file etc/fstab

check the output to see if one or both of your files got restored. If not, 
continue with the previous backup, up to the time you have seen for each file
a line indicating it been restored. Note that the most recent version of each 
files may not be located in the same archive, thus you might get /etc/fstab
restored from linux_diff28, and /home/denis/my_precious_file restored at 
linux_diff27. In the case /etc/fstab is also present in linux_diff27 it would
not have been overwritten by an older version, thanks to the -r option. Thus,
this option is very important where restoring more than one file using the
second method. Instead, in the first method (restoring first from
the full backup, then from all the following differential backups), -r option
is not so important as if overwriting occurs when you restore lost files, 
you would only overwrite an older version by a newer.

same thing here, even if you are not lazy, dar_manager can help you much here,
to automate the restoration of a set of file.
How much can you restore with dar_manager ? as much as you can give to 
dar_manager as argument on command line. dar_manager, the last children of dar
suite, will certainly be improved in the future.




