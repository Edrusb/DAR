<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>DAR - Tutorial</title>
</head>
<body
 style="background-color: rgb(221, 221, 221); color: rgb(0, 0, 170);"
 link="#0000ff" vlink="#000055" alink="#ff0000">
<center>
<table
 style="width: 90%; text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; width: 161px;"><a
 href="index.html"><img
 style="border: 0px solid ; width: 160px; height: 120px;"
 alt="Dar Documentation" src="dar_s_doc.jpg"></a><br>
      </td>
      <td style="vertical-align: top;">
      <h1 style="text-align: center;"><br>
      </h1>
      <h1 style="text-align: center;">TUTORIAL</h1>
      </td>
    </tr>
  </tbody>
</table>
<h1 style="text-align: center;"></h1>
<br>
<hr style="width: 100%; height: 2px;"><br>
<span style="font-weight: bold;"></span>
<table
 style="width: 90%; text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <h2 style="text-align: justify;">Introduction</h2>
      <div style="margin-left: 40px; text-align: justify;">This little
tutorial shows you how to backup your file system (partially or
totally) on ZIP drives.<br>
      </div>
      <div style="text-align: justify;"><br>
      </div>
      <h3>STEP 1: The FULL backup<br>
      </h3>
      <div style="text-align: justify;">We need first to make a full
backup, let's go:<br>
      <br>
The size of a zip drive is 100 MB,<br>
*** here comes the option: -s 100M<br>
This tells dar to not create a single backup file but to split it in
several files with a size of at most 100 Megabytes.<br>
      <br>
On your first ZIP drive we want to copy the dar binary outside the
backup to be able to restore it in case of hard disk failure, for
example. <span style="text-decoration: underline; font-weight: bold;">IMPORTANT:</span>
dar binary relies on several libraries which must also be available in
the rescue system or copied with the dar binary. But, if you don't want
to worry about needed libraries, there is a static version of dar which
only difference is that it has all required library included in the
binary (thus it is a slightly larger binary). Its name is "<span
 style="font-weight: bold;">dar_static</span>",
and its main reason of existence is to be placed beside backups in case
something goes wrong in your system. Note that dar_static is useless
for windows, you will always need the <a href="http://cygwin.com/">Cygwin</a>
dll. <br>
      <br>
(You could also add man pages, if you are scared not to be able to
remember all the many feature of dar ;-) and find the -h option too
sparse). Note that man pages are available on the web. OK you need an
Internet access to read them.<br>
      <br>
This make the free space on the first ZIP floppy a bit smaller: 95 MB.<br>
*** Here comes the option: -S 95M<br>
(Note that '-s' is lowercase for all the slices, and '-S' is UPPERCASE
meaning the initial slice only).<br>
      <br>
We need to pause between slices to change the ZIP floppy when it is
full <br>
*** here comes the option: -p -b<br>
telling dar to pause before writing a new slice (-p) and to ring the
terminal bell (-b) when user action is needed.<br>
      <br>
We will compress data inside the backup <br>
*** here comes the option: -z<br>
-z uses gzip compression algorithm, but you could also use -y to use
bzip2 compression. Optionally, if speed is more important than archive
size, you can degrade compression specifying the compression level :
-z1 for example.&nbsp; <br>
      <br>
Now, we want to backup the whole file system. <br>
*** here comes the option: -R /<br>
This tells dar that no files out of this directory tree will be saved
(here, it means that no files will be excluded from the backup, if no
filter is specified, see below)<br>
      <br>
There are some files you don't want to backup like backup files
generated by emacs "*~" and .*~".<br>
*** here comes the options: -X "*~" -X ".*~"<br>
Note that you have to quote the mask for it not to be interpreted by
the shell the -X options do not apply to directories, nor to path, they
just apply to<br>
filenames. (see also -I option in man page for more information)<br>
      <br>
Among these files are several sub-trees you must not save: the /proc
file system for example, as well as the /dev/pts . Theses are virtual
file systems, saving them would only make your backup bigger filled
with useless stuff.<br>
*** here come the options: -P dev/pts -P proc<br>
Note that path must be relative to -R option (thus no leading '/' must
be used) Unlike the -X/-I options, the -P can apply to a directory. If
a directory matches -P option, all its subdirectory will also be
excluded. note also that -P can receive wilder cards, and they must be
quoted not to be interpreted by the shell: -P "home/*/.mozilla/cache"
for example. Lastly, -P can also be used to exclude a plain file (if
you don't want to exclude all files of a given name using -X option):
-P home/joe/.bashrc for example would only exclude joe's .bashrc file
not any other file, while -X .bashrc will exclude any file of that name
including joe's file. (see also -g option in man page for more)<br>
      <br>
More importantly we must not save the backup itself:<br>
*** here comes the option: -P mnt/zip<br>
assuming that your ZIP is mounted under /mnt/zip . We should also have
excluded all files of extension "dar" which are backup generated by dar
with -X "*.*.dar", but this would exclude other dar archive from the
backup, which may not always fit your need.<br>
      <br>
Now, as we don't save the /dev/pts /proc and /mnt/zip directories, we
would have to create them by hand at recovery time. But we can better
use the -D option, which does not totally ignore excluded directories
but rather stores them as empty.<br>
*** here comes the option -D<br>
thus at recovery time they will be generated automatically<br>
      <br>
Lastly, we have to give a name to this full backup. Let's call it
"linux_full" as it is supposed to take place on the ZIP drive, its path
is /mnt/zip/linux_full<br>
*** here comes the option: -c /mnt/zip/linux_full<br>
Note that linux_full is not a complete filename, it is a "basename", on
which dar will add a number and an extension ".dar", this way the first
slice will be a file of name linux_full.1.dar located in /mnt/zip<br>
      <br>
Now, as we will have to mount and umount the /mnt/zip file system, we
must not have any process using it, in particular, dar current
directory must no be /mnt/zip so we change to / for example.<br>
      <br>
All together we follow this procedure for our example:<br>
      <br>
Put an empty ZIP floppy in the device, and mount it according to your
/etc/fstab file.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mount
/mnt/zip</code><br>
      </div>
      <div style="text-align: justify;"><br>
Copy the dar binary to the zip drive (to be able to restore in case of
big problem, like a crash disk) and eventually man pages<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>cp
`which dar_static` /mnt/zip</code><br>
      </div>
      <div style="text-align: justify;"><br>
then, type the following<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>cd /</code><br>
      <code>dar -c /mnt/zip/linux_full -s 100M -S 95M -p -b -z -R / -X
"*~" -X ".*~" -P dev/pts -P proc -P mnt/zip -D</code><br>
      <code></code></div>
      <div style="text-align: justify;"><br>
Note that option order has no importance. Some options may be used
several times (-X, -I, -P) some others cannot (see man page for more).<br>
When the first slice will be done, DAR will pause, ring and display a
message. You will have to unmount the floppy<br>
      <code></code><br>
      <code></code></div>
      <div style="margin-left: 40px; text-align: justify;"><code>umount
/mnt/zip<br>
      <br>
      </code></div>
      <div style="text-align: justify;">eject and replace the floppy by
an empty new one and mount it<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mount
/mnt/zip</code><br>
      </div>
      <div style="text-align: justify;"><br>
To be able to to that, you can swap to another virtual console pressing
ALT+F? keys, or open another xterm if under X-Windows, and suspend dar
by typing CTRL-Z and reactivating it after mounting/unmounting by
typing `fg` (without the quotes).<br>
      <br>
Then proceed with dar, pressing the &lt;enter&gt; key.<br>
      <br>
Dar will label slices this way:<br>
slice 1: linux_full.1.dar<br>
slice 2: linux_full.2.dar<br>
and so on.<br>
      <br>
That's it! We finished the first step, it may take a long time
depending on the size of the data to backup, The following step
(differential backup) however can be done often, and it will stay fast
every time (OK, except if a big part of your system have changed, in
that case you can consider making another full backup).<br>
      <br>
Just a little check on the archive you've just made: suppose you want
to read the content of the backup you made, you would have<br>
to run:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -l
/mnt/zip/linux_full</code><br>
      </div>
      <div style="text-align: justify;"><br>
Optionally if you don't trust your zip floppies, you can either check
the archive contents, or compare what's stored in it with the current
file system.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -t
/mnt/zip/linux_full</code><br>
      </div>
      <div style="text-align: justify;"><br>
will check the whole archive.<br>
      <br>
It is recommended to first unmount it and remount it, this to flush the
cache. Else you may read data from cache (in memory) and do not detect
an error on you floppy. dar -t cannot check a single slice, it checks
all the archive. If you need to check a single slice (for example after
burning it on CD) you can use the diff command : for example, you burn
the last completed slices on CD-R, but have just enough free space to
store one slice on disk. You can thus check the slice typing something
like:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>diff
/mnt/cdrom/linux_full.132.dar /tmp/linux_full.132.dar</code><br>
      </div>
      <div style="text-align: justify;"><br>
where 132 has to be replaced by the real slice number.<br>
      <br>
If all is ok (which is when diff does not complain), you can delete the
slice from the hard disk (/tmp/slice.x.dar), and continue with dar.
Else, you will have to burn again the slice on a new CD-R.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -d
/mnt/zip/linux_full -R /</code><br>
      </div>
      <div style="text-align: justify;"><br>
will compare the archive with filesystem tree located at / . Same
remark as previously, it is recommended to first unmount and mount the
floppy to flush the system cache.<br>
      <br>
      </div>
      <h3 style="text-align: justify;">STEP 2: DIFFERENTIAL BACKUP</h3>
      <div style="text-align: justify;">The only thing to add is the
base name of the backup we take as reference<br>
*** here comes the option: -A /mnt/zip/linux_full<br>
      <br>
Of course, we have to choose another name for that backup, let's call
it linux_diff1<br>
*** here comes the option: -c /mnt/zip/linux_diff1<br>
      <br>
Last point: if you want to put the new backup at the end of the full
backup, you will have to change the -S option according to the
remaining space on it. suppose the last slice of linux_full takes 34MB
you have 76MB available for the first slice of the differential backup
(and always 100MB for the following ones),<br>
*** here comes the option: -S 76M<br>
but if you want to put the backup on a new floppy, just forget the -S
option.<br>
      <br>
All together we get:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -c
/mnt/zip/linux_diff1 -A /mnt/zip/linux_full -s 100M -S 76M -p -b -z -R
/ -X "*~" -X ".*~" -P dev/pts -P proc -P mnt/zip -D</code><br>
      </div>
      <div style="text-align: justify;"><br>
the same way we have done previously, just before effectively starting
to backup, dar will ask for the first and then the last slice of the
archive of reference, then dar will pause for you to change the floppy
and put the one you want to put the backup on (thanks to the -p option).<br>
      <br>
      </div>
      <h3 style="text-align: justify;">STEP 3: ENDLESS DIFFERENTIAL
BACKUP</h3>
      <div style="text-align: justify;">You can make another
differential backup, taking linux_diff1 as reference, in this case you
would change only the following<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>-c
/mnt/zip/linux_diff2 -A /mnt/zip/linux_diff1</code><br>
      </div>
      <div style="text-align: justify;"><br>
You could also decide to change of device, taking a 1'44MB floppy or a
CD-R,&nbsp; this would not cause any problem at all. It arrives a time
when
you get many differential backup for a single full backup, it is then
time to make a new full backup, depending on your available time for
doing it, or on your patient if one day you have to recover the whole
data after a disk crash: You would then have to restore the full
backup, then all the following differential backup up to the most
recent one. This requires more user intervention than restoring a
single full backup, all is a matter of balance, between the time it
takes to backup and the time it takes to restore. <br>
      <br>
Note, that starting release 1.2.0 a new command appeared that helps
restoring a small set of file from a lot a differential backup. Its
name is dar_manager. See at the end of this tutorial and man page for
more.<br>
      <br>
Another solution, is when you have too much differential backup, is to
make the next differential backup taking the last full_backup as
reference, instead of the last differential backup done. This way, it
will take less time than doing a full backup, and you will not have to
restore all intermediate differential backup. Some people make
difference between "incremental" backup and "differential" backup. Here
they are the same, all depends on the nature of the reference backup
you take.<br>
      <br>
Of course, a given backup can be used as reference for several
differential backup, there is no limitation in number nor in nature
(the reference can be a full of differential backup).<br>
      <br>
      <br>
      </div>
      <h3 style="text-align: justify;">STEP 4: RECOVER AFTER A DISK
CRASH</h3>
      <div style="text-align: justify;">Sorry, it arrived, your old
disk has
crashed. OK, you are happy because you have now a good argument to buy
the very fast and very enormous very last hard disk available. Usually,
you also cry because you have lost data and you will have to reinstall
all your system, that was working for so long! <br>
      <br>
If however the last backup you made is recent, then keep smiling! OK,
you have installed your new hard disk and configured you BIOS to it (if
necessary). You will need a bootable floppy, with a minimum Linux
system on it, that allows you to access your zip drive and your new
empty hard disk (in the case your backup resided on ZIP disk). For
example use the Slackware floppy disks, they are nicely done. You don't
need to install something on your brand-new disk, just make partitions
and format as you want: We suppose your new disk is /dev/hda and
/dev/sga is your ZIP drive. <br>
      <br>
1. Create the partition table as you wish, using<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>fdisk
/dev/hda</code><br>
      </div>
      <div style="text-align: justify;"><br>
2. Format the ext2 partition which will receive your data<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mke2fs
/dev/hda1</code><br>
      </div>
      <div style="text-align: justify;"><br>
3. Additionally format the swap partition (if needed)<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mkswap
-c /dev/hda2</code><br>
      </div>
      <div style="text-align: justify;"><br>
3bis. If you have a lot of file to restore, you can activate the swap
on the partition of your new hard drive:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>swapon
/dev/hda2</code><br>
      </div>
      <div style="text-align: justify;"><br>
4. Now we must mount the hard disk, somewhere.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>cd /</code><br>
      <code>mkdir disk</code><br>
      <code>mount -t ext2 /dev/hda1 /disk<br>
      <br>
      </code></div>
      <div style="text-align: justify;">would do the trick<br>
      <br>
4bis. If you want to restore your system over several partitions like
/usr /var /home and / you must create the partitions, format them. Then
create the directories that will be used as mounting point an mount the
partitions on theses directories <br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mkdir
/disk/usr /disk/var /disk/home<br>
mount -t ext2 /dev/hda2 /disk/usr<br>
mount -t ext2 /dev/hda3 /disk/var<br>
mount -t ext2 /dev/hda4 /disk/home<br>
      <br>
      </code></div>
      <div style="text-align: justify;">for example if you have / /usr
/var and /home partitions.<br>
      <br>
5. We need to copy the dar binary from the ZIP to your disk insert the
floppy ZIP where you have copied the dar binary<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code><br>
cd /</code><br>
      <code>mkdir zip</code><br>
      <code>mount -t ext2 /dev/sga /zip</code><br>
      <code>cp /zip/dar_static /disk<br>
      <br>
      </code></div>
      <div style="text-align: justify;">where /dev/sga points to your
zip drive<br>
      <br>
6. Now we restore the archive. The stuff has to go in /disk subdirectory<br>
*** here comes the option: -R /disk<br>
      <br>
7. The process may be long, thus it might be useful to be noticed when
a user action is required by dar.<br>
*** here comes the option: -b<br>
      <br>
let's go restoring!<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>/disk/dar_static
-x /zip/linux_full -R /disk -b</code><br>
      </div>
      <div style="text-align: justify;"><br>
... and when the next zip floppy is needed,<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>umount
/zip</code><br>
      </div>
      <div style="text-align: justify;">change the floppy and mount it:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>mount
-t ext2 /dev/sga /zip</code><br>
      </div>
      <div style="text-align: justify;">as previously, use an alter
xterm /
virtual console or suspend dar by CTRL-Z and awake it back by the 'fg'
command. Then press &lt;enter&gt; to proceed with dar<br>
      <br>
      <br>
7. Once finished with the restoration of linux_full, we have to do the
same with any following backup, This way however will warn you any time
it restores a more recent file (file overwriting) or any time a file
that has been removed since the backup of reference, has to be removed
from file system (suppression). If you don't want to press the
&lt;enter&gt; key several thousand times: <br>
*** here comes the option: -w<br>
(don't warn). All file will be overwritten without warning, but you may
also use the -r option, that will avoid trying to overwrite more recent
files than those on filesystem. It might not be of a great use, if you
restore a differential backup after its reference backup on an
initially empty disk (file stored in the differential archive are more
recent than those in the reference). But, it might be useful in some
other situations.<br>
      <br>
All together it makes:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>/disk/dar_static
-x /zip/linux_diff1 -R /disk -b -w</code><br>
      </div>
      <div style="text-align: justify;"><br>
Then any additional archive:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>/disk/dar_static
-x /zip/linux_diff2 -R /disk -b -w<br>
...<br>
/disk/dar_static -x /zip/linux...&nbsp;&nbsp;&nbsp; -R /disk -b -w</code><br>
      </div>
      <div style="text-align: justify;"><br>
8. Finally, remove the dar binary from the disk:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>rm
/disk/dar_static</code><br>
      </div>
      <div style="text-align: justify;"><br>
9. And launch lilo for your Linux box to boot properly (if needed):<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>lilo
-r /disk</code><br>
      </div>
      <div style="text-align: justify;"><br>
10. You can reboot you machine and be happy with you brand-new hard
disk with your old precious data on it:<br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>shutdown
-r now</code><br>
      </div>
      <div style="text-align: justify;"><br>
OK, one day, I will make something like a bootable floppy image with
dar inside, maybe with a simple script for user interaction... if you
have already done it, you can tell or send&nbsp; me (or give me the URL
where to get it, for I add a hyperlink on DAR's Homepage). [Note:
Knoppix seems to include dar]<br>
      <br>
      </div>
      <h3 style="text-align: justify;">STEP 4(bis): recover only some
files</h3>
      <div style="text-align: justify;">Gosh, you have remove a
important
file by error. Thus, you just need to restore it, not the rest of the
full and differential backups.<br>
      <br>
      </div>
      <h4 style="text-align: justify;">a) First method:</h4>
      <div style="text-align: justify;">We could as previously, try all
archive starting from the full backup up to the most recent
differential backup, and restore just the file if it is present in the
archive:<br>
      <code></code><br>
      <code></code></div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -R
/ -x /zip/linux_full&nbsp; home/denis/my_precious_file</code><br>
      </div>
      <div style="text-align: justify;"><br>
This would restore only the file /home/denis/my_precious_file from the
full backup.<br>
      <br>
OK, now we would also have to restore from all differential backup the
same way we did. Of course, this file may have changed since the full
backup.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -R
/ -x /zip/linux_diff1&nbsp; home/denis/my_precious_file</code><br>
      </div>
      <div style="text-align: justify;"><br>
and so on, up to the last differential archive.<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -R
/ -x /zip/linux_diff29&nbsp; home/denis/my_precious_file</code><br>
      </div>
      <div style="text-align: justify;"><br>
      <br>
      </div>
      <h4 style="text-align: justify;">b) Second method (more
efficient):</h4>
      <div style="text-align: justify;">We will restore our lost file,
starting from the most recent differential backup and *maybe* up to the
full backup. Our file may or may not be present in the each
differential archive as it may have changed or not since the previous
version, thus we have to check if our file is restored, using the -v
option (verbose):<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -R
/ -x /zip/linux_diff29 -v home/denis/my_precious_file</code><br>
      </div>
      <div style="text-align: justify;"><br>
If we can see a line like<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>restoring
file: /home/denis/my_precious_file</code><br>
      </div>
      <div style="text-align: justify;"><br>
The it stops here, because we got the most recent backup version of our
lost file. We have to otherwise have to continue with the previous
differential backup, up to the full backup if it is necessary. This
method has an advantage over first one, which is not to have *in all
case* the need to use all the backup done since the full backup.<br>
      <br>
If you are lazy on the other hand, have a look at dar_manager (at the
end of the tutorial)<br>
      <br>
OK, now you have two files to restore. No problem, just do the second
method but add -r option not to override any more recent file already
restored in a previous step:<br>
      <code></code><br>
      <code></code></div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -x
/zip/linux_diff29 -R / -r -v home/denis/my_precious_file etc/fstab</code><br>
      </div>
      <div style="text-align: justify;"><br>
Check the output to see if one or both of your files got restored. If
not, continue with the previous backup, up to the time you have seen
for each file a line indicating it been restored. Note that the most
recent version of each files may not be located in the same archive,
thus you might get /etc/fstab restored from linux_diff28, and
/home/denis/my_precious_file restored at linux_diff27. In the case
/etc/fstab is also present in linux_diff27 it would not have been
overwritten by an older version, thanks to the -r option. <br>
      <br>
This option is very important where restoring more than one file using
the second method. Instead, in the first method (restoring first from
the full backup, then from all the following differential backups), -r
option is not so important as if overwriting occurs when you restore
lost files, you would only overwrite an older version by a newer.<br>
      <br>
Same thing here, even if you are not lazy, dar_manager can help you
lots here to automate the restoration of a set of file.<br>
      <br>
How much can you restore with dar_manager?&nbsp; As much as you can
give to
dar_manager as argument on command line or through&nbsp; included files
(-B
option).<br>
      <br>
      <br>
      </div>
      <h3 style="text-align: justify;">DAR_MANAGER TUTORIAL</h3>
      <div style="text-align: justify;">dar_manager builds a database
of all
your archive contents, to automatically restore the latest versions of
a given set of files. First, we have to create a "database" file :<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-C my_base.dmd</code><br>
      </div>
      <div style="text-align: justify;"><br>
This created a file "my_base.dmd" where dmd stands for Dar Manager
Database, but you are free to use any other filename. <br>
      <br>
This database is created empty. Each time you make a backup, may it be
full or differential, you will have to add its catalogue to this
database using the&nbsp; following command:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -A /mnt/zip/linux_full<br>
      </code></div>
      <div style="text-align: justify;"><br>
This will add ("A" stands for "add") the archive contents to the base.
In some cases you may not have the archive available but its extracted
catalogue instead. Of course, you can use the extracted catalogue in
place of the archive!<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -A ~/Catalogues/CAT_linux_full</code><br>
      </div>
      <div style="text-align: justify;"><br>
The problem however is that when dar_manager will need to recover a
file located in this archive it will try to open the
archive&nbsp;&nbsp;
~/Catalogue/CAT_linux_full for restoration, which does not contain any
data because it is just the catalogue of the archive.<br>
      <br>
No problem if you made this mistake, thanks to the -b option we can
change the basename of the archive, and thanks to the -p option you can
change the path at any time. But first we will list the database
contents:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -l</code><br>
      </div>
      <div style="text-align: justify;"><br>
It shows the following:<br>
      <br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar
path&nbsp;&nbsp;&nbsp; :<br>
dar options :<br>
      <br>
archive #&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; basename<br>
------------+--------------+---------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/home/denis/Catalogues&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CAT_linux_full<br>
      </code></div>
      <div style="text-align: justify;"><br>
We should change the path of archive number 1 for dar_manager looks on
the zip drive:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -p 1 /mnt/zip</code><br>
      </div>
      <div style="text-align: justify;"><br>
and also replace the name of the extracted catalogue by the real
archive name<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -b 1 linux_full</code><br>
      </div>
      <div style="text-align: justify;"><br>
Now we have exactly the same database as if we had use the real archive
instead of its catalogue:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -l</code><br>
      </div>
      <div style="text-align: justify;"><br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar
path&nbsp;&nbsp;&nbsp; :<br>
dar options :<br>
      <br>
archive #&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; basename<br>
------------+--------------+---------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mnt/zip&nbsp;&nbsp;&nbsp;&nbsp;
linux_full<br>
      </code></div>
      <div style="text-align: justify;"><br>
      <br>
In place of using -b and -p options, you can also tell the path and the
name of the real archive to use at restoration time this way:<br>
      <br>
      </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -A ~/Catalogues/CAT_linux_full /mnt/zip/linux_full</code><br>
      </div>
      <br>
This is done adding an optional argument. The first ~/Catalogue... is
the archive to add, and the second /mnt/zip... is the name to keep for
it. No access is done to this archive, thus it may be not available at
the time the command is typed.<br>
      <br>
You can add up to 65534 archives to a given database, and have as much
base as you want.<br>
      <br>
Suppose after each backup you took the time to update your database,
and now you just have removed an important file by error.<br>
      <br>
Firstly, we did not yet gave important options in the database to be
passed to dar. For example, you will likely restore from the root of
your filesystem, therefor dar when called from dar_manager must get the
"-R /" option. This is done with:<br>
      <br>
      <div style="text-align: justify;"> </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -o -R /</code><br>
      </div>
      <br>
All that follows -o is passed to dar as-is. You can see the options
passed to dar when listing the database contents (-l option).<br>
      <br>
Now, we can restore our /home/denis/my/precious/file :<br>
      <br>
      <div style="text-align: justify;"> </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar_manager
-B my_base.dmd -r home/denis/my/precious/file</code><br>
      </div>
      <br>
dar_manager will find the proper archive to use, and call dar with the
following options:<br>
      <br>
      <div style="text-align: justify;"> </div>
      <div style="margin-left: 40px; text-align: justify;"><code>dar -x
&lt;archive&gt; -R / home/denis/my/precious/file</code><br>
      </div>
      <div style="text-align: justify;"><br>
Which in turn will ask you the corresponding slices.<br>
      <br>
Once an archive become obsolete you can delete it from the database
thanks to the -D option, you can also change archive order (-m option),
get a list in which is located a given file (-f option), get the list
of most recent files in a given archive (-u option), and get overall
statistics per archive (-s option). Lastly you can specify which dar
command to use given its path (-d option), by default, dar_manager uses
the PATH shell variable to choose the dar command.<br>
      </div>
      </td>
    </tr>
  </tbody>
</table>
<span style="font-weight: bold;"></span><br>
<div style="text-align: justify;"><br>
<br>
</div>
<br>
<br>
</center>
</body>
</html>
