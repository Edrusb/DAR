<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>DAR's Limitations</title>
</head>
<body
 style="background-color: rgb(221, 221, 221); color: rgb(0, 0, 170);"
 link="#0000ff" vlink="#000055" alink="#ff0000">
<table
 style="width: 90%; text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; width: 161px;"><a
 href="index.html"><img
 style="border: 0px solid ; width: 160px; height: 120px;"
 alt="Dar Documentation" src="dar_s_doc.jpg"></a><br>
      </td>
      <td style="vertical-align: top;">
      <h1 style="text-align: center;"><br>
      </h1>
      <h1 style="text-align: center;">DAR's Limitations</h1>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<hr style="width: 100%; height: 2px;"><br>
<table
 style="width: 90%; text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Here follows a description of
the known limitation you should consult before creating a bug report
for dar:<br>
      <br>
      <h2 style="text-align: justify;">Fixed Limits</h2>
      <ul style="text-align: justify;">
        <li>The size of SLICES may be limited by the file system or
kernel (maximum file size is 2 GB with Linux kernel 2.2.x),</li>
        <li>the number of SLICES is only limited by the size of the
filenames, thus using a basename of 10 chars, considering your file
system can support 256 char per filename at most, you could already get
up to&nbsp; 10^241 SLICES, 1 followed by 241 zero. But as soon as your
file
system will support bigger files or longer filename, dar will follow
without change.</li>
        <li>dar_manager can gather up to 65534 different backups. This
limit should be high enough to not be a problem.<br>
        </li>
      </ul>
      <br>
      <h2 style="text-align: justify;">System variable limits</h2>
      <h3 style="text-align: justify;">Memory</h3>
      <div style="text-align: justify;">Dar uses virtual memory (=
RAM+swap) to be able to add the list of file
saved at the end of each archive. Dar uses its own integer type (called
"infinint") that do not have limit (unlike 32 bits or 64 bits
integers). This makes dar already able to manage Zettabytes volumes and
above even if the systems cannot yet manage such file sizes.
Nevertheless, this has an overhead with memory and&nbsp; CPU usage,
added to
the C++ overhead for the datastructure. All together dar needs a
average of 650 bytes of virtual memory by saved file. Thus, for example
if you have 110,000 files to save, whatever is the total amount of data
to save, dar will require around 67 MB of virtual memory.<br>
      </div>
      <br>
      <div style="text-align: justify;">Now, when doing catalogue
extraction or differential backup, dar has in
memory two catalogues, thus the amount of memory space needed is the
double (134 MB in the example). Why ? Because for differential backup,
dar starts with the catalogue of the archive of reference which is
needed to know which files to save and which not to save, and in
another hand, builds the catalogue of the new archive all along the
process. Now, for catalogue extraction, the process is equivalent to
making a differential backup just after a full backup.<br>
      </div>
      <br>
      <div style="text-align: justify;">This memory issue, is not a
limit by itself, but you need enough
virtual memory to be able to save your data (if necessary you can still
add swap space).<br>
      </div>
      <br>
      <h3 style="text-align: justify;"><a name="Integers"></a>Integers</h3>
      <div style="text-align: justify;">To overcome the previously
explained
memory issue, dar can be build in an other mode. In this other mode,
"infinint" is replaced by 32 bits or 64 bits integers, as defined by
the use of --enable-mode=32 or --enable-mode=64 options given to
configure script. The executables built this way (dar, dar_xform,
dar_slave and dar_manager) run faster and use much less memory than the
"full" versions using "infinint". But yes, there are drawbacks:&nbsp;
slice
size, file size, dates, number of files to backup, total archive size
(sum of all slices), etc, are bounded by the maximum value of the used
integer, which is 4,294,967,296 for 32 bits and
18,446,744,073,709,551,616 for 64 bits integers.&nbsp; In clear the 32
bits
version cannot handle dates after year 2106 and file sizes over 4 GB.
While the 64 bits version cannot handle dates after around 500 billion
years (which is longer than the estimated age of the Universe: 15
billion years) and file larger than around 18 EB (18 exa bytes). <br>
      </div>
      <br>
      <div style="text-align: justify;">What the comportment when such
a
limit is reached ? For compatibility with the rest of the code, limited
length integers (32 or 64 for now) cannot be used as-is, they are
enclosed in a C++ class, which will report overflow in arithmetic
operations. Archives generated with all the different version of dar
will stay compatible between them, but the 32 bits or 64 bits will not
be able to read or produce all possible archive. In that case, dar
suite program will abort with an error message asking you to use the
"full" version of dar program.<br>
      </div>
      <br>
      <h3 style="text-align: justify;">Command line</h3>
      <div style="text-align: justify;">On several systems,
command-line long
options are not available. This is due to the fact that dar relies on
GNU getopt. Systems like FreeBSD do not have by default GNU getopt,
instead the getopt function proposed from the standard library does not
support long options, nor optional arguments. On such system you will
have to use short options only, and to overcome the lack of optional
argument you need to explicitly set the argument. For example in place
of "-z" use "-z 9" and so on. All options for dar's features are
available with FreeBSD's getopt, just using short options and explicit
arguments.<br>
      </div>
      <br>
      <div style="text-align: justify;">Else you can install GNU getopt
as a
separated library called libgnugetopt. If the include file
&lt;getopt.h&gt; is also available, the configure script will detect it
and use this library. This way you can have long options on FreeBSD for
example.<br>
      </div>
      <br>
      <h3 style="text-align: justify;">Dates</h3>
Unix files have three dates :<br>
      <ul style="text-align: justify;">
        <li>last modification date (mtime)</li>
        <li>last access date (atime)</li>
        <li>last inode change (ctime)</li>
      </ul>
      <div style="text-align: justify;">In dar dates are stored as
integers (the number of seconds elapsed
since Jan 1st, 1970). As seen above, the limitation is not due to dar
but on the integer used, so if you use infinint, you should be able to
store any date as far in the future as you want. Of course dar cannot
stores dates before Jan the 1st of 1970, but it should not be a very
big problem. ;-)<br>
      </div>
      <br>
      <div style="text-align: justify;">There is no standard way under
Unix
to change the ctime. So DAR does not save ctime date (except when
saving EA) nor it tries can restore it. Reading a file (when doing a
backup or a comparison) updates the atime of the read files. Some
applications like leafnode (an NNTP cache) base their expiry time on
the atime. So since the beginning and still by default, dar sets back
the atime of file it reads. But changing the atime updates the ctime,
which cannot be set back to its original value. As the ctime was not
taken in account this was not a problem to me until I got feedback that
some security tool base their inspection on the ctime (A file that had
the ctime changed is most probably changed, in particular if the atime
has not changed, this may indicate a dissimulation). So there is now a
special mode in which dar does not try to set back the atime of files
which preserves the ctime.<br>
      </div>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
</body>
</html>
